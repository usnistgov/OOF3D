
  Feb. 21, 2020 --

  Closing in on plasticity, but starting to side-line a few 
important issues.  They're collected here.


  Done:  
    Time is now passed in to the stepper, the plasticity property
      deduces dt at run-time.
 
    Stepper appears to be operating correctly, but differs from the
      prototype code due to the prototype's use of a different
      method (the "penalty method") to do the fixed BCs.  

    Integrals are done correctly with the right Jacobian.

    Outputs work for evaluations at gausspoints, which involved
      most of the infrastructure.  Needs to be generalized.

  Pending: 
  - The NR solver has this tricky business where it selects an 
      optimal step size.  But extra evaluations of make_linear_system
      trigger physical changes by adding additional plastic strain.
      Is this OK?  (Temporarily disabled.)

  - The NR solver also bombs out if it exceeds its allotted step
      count, but in plasticity, general practice is that a small
      number of steps is OK.  Currently, it's modified to continue
      after exceeding the step count, but what we really want is
      a better convergence criterion, probably.

  Todo:

  2nd:
  - The NR solver in OOF differs from the prototype code in that
      it's computing very high stresses for the initial time steps.
      It's not obvious why it should do this, but the initial stress
      looks very much like it's maybe some kind of purely elastic
      number?
    First guess is that the the starting K at the start of each
      time-step is somehow the initial K?  Probably the prior K 
      matrix is not being saved.

  - Outputs are basically working, but need to evaluate plastic 
      info at arbitrary points in space, not just GPs.
      
  - In the NR solver, it would be useful to provide it with an
      initial guess for the delta for the first iteration.
    SK says he does this with the deltas from the static step?

  - The NR solver requires the residual to be computed -- 
      double-check that the new equation class is actually doing this
      in the right way.
    In particular:  The property is populating a "static flux value"
      member of the fluxdata object, which goes into the "residual"
      data member of the LinearizedSystem class, but it's not the
      residual, it's the flux, which is combined with the applied
      forces when it's pulled out.
 
  1st:
  - In the equation construciton process, we're still not doing
      the geometrically-nonlinear piece, the equation is the standard
      OOF equation with a nonlinear constitutive rule.
    Fixing this involves re-working the property classes, 
      no more Flux or Eqn properties, just properites that 
      make contributions to one or the other or both.

  - Double-check the caching, see if we're doing too much work.
    - Sub-item: Shape function derivs could benefit from 
       caching answers, and knowing when the displacement field
       has changed.

  - There is an implicit assumption that there are only displacement
      DOFs in the subproblem.  This is likely to be true for real
      problems, but should maybe be more robust.

  - Possibly the property should be smarter about its statefullness,
      if it knew it was being evaluated "again" at a time-step, it
      could save some work and/or retrieve old data?
    This involves adding the time to the GptData object, and a check
      to notice new times.
    Allows the time-step to be nonuniform, also, which is handy.
    A possible mechanism for this is, if are being called for a
      time t and deformation F that you have seen before, just
      return the data you already have.

  - The OOF infrastructure is built for a general nonlinear solver,
      which might be either Newton or Picard -- they differ in what
      functions they call to retreive data, we should investigate
      if it makes sense to plasticity to use the Picard solvers.
      (TODO 1st: Review how Picard solvers work...)

  - We may have assumed that IncrementalStepper increments and the 
      requested outputs are commensurate, so we never have to take
      a partial step?  Check this.

  - The currently-coded incremental stepper is incapable of taking
      a linear step.  Incremental linear steps are trivial, you just
      statically evaluate at the new time.  This is a weird thing to 
      want, so we're deferring implementation of this.
 
  - What does it actually really mean for the time-stepper to 
      return stepOK?  Does it mean it reached the target, or just
      that it took a single step successfully?
 
  ------------
  
  Oct. 2022 -- diving into things a bit more.

  Built a bunch of instrumentation for the code, and now using the
"outline mode" scheme in Emacs to get a better grip on things.

  Having understood the stepper sequence better, there are a couple
of mysteries -- for the all_up_newtime_io.txt ouptut file, with the
delta-T of 1, if you *remove* the extra K-matrix construction from
evolve (line 365 of engine/evolve.py), the evolution gets into 
problems around time-step 75, where the BSB Q inversion failes.
  Tightening up the time-step fixes it.

  We are doing extra work, and the newly-built K is elastic (we think?),
so it leads to fairly high stresses, so our first guess was that by
*removing* the spurious K, we would get more stable results, but we
are seeing the opposite.

  Maybe the elastic(?) K is doing something different?  Getting ahead
of the stress, and somehow indirectly stabilizing the later iterations,
so when you remove it, things get worse?  This is unintuitive.

  Other q's: Impact of the large-deformation terms?  Possibly this is
too large, we think it's larger than the prototype code's result for
the same problem.

  Things to test:
 
  Try to do up to T=1000 (10% strain) with a smaller time-step and
see if we recover convergence for both extra-K and non-extra-K cases.

  Without the extra K, it seems to fall over even at delta-T=0.5.
  With the extra K, it can go up to 10% strain without falling
    into NANs, although the accuracy remains an open question.

  ----------------

  Nov. 10, 2022 --

  Comparing carefully against the prototype code, we are seeing
scary thing -- the elastic constant seems to be wrong, for one thing,
and the power-law seems to not be happening, there's no curvature
to the hardening part of the thing.

  To do: Do some runs with the plasticity hacked out to check 
if it's the plasticity or the solver that's screwing things up.

  Also, geometric vs non-geometric?  
  
  Audit the stuff in the code, and find earlier versions of the code
that do the right thing.

  -------------------

  Nov. 15, 2022 -- 

  Stress/strain curve complicated by not being super-clear which
strain measure we're using.  SK will re-do with GL, I will re-do
with logarithmic.

  -------------

  Nov. 29, 2022 --

  Useful quantities:

  We want to make the diagnostic data more navigable, so do that.

  Start with delta-gamma.
  If it's weird, look at tau-alpha (the resolved shear stress).
  If *that* is weird, then S, the 2nd PK stress.  
  If *that* is weird, then the Cauchy stress.
  If *that* is weird, then K. 

  -----------
 
  Want convenient access to cauchy stress in the output.

  ---------------

  Jan. 2023:

  - Trying to compare the outputs with the prototype code, finally
realized that the codes had different outputs -- now OOF is using
the xx component of the logarithmic strain and the xx component of
the Cauchy stress, plus there was a secondary issue where the OOF
code was not sampling the outputs very frequently in time.  That's
all fixed, and the current state is that we have a very good match
in the elastic regime, but once it starts to yield, the OOF code
stress numbers are systematically higher than the prototype code.

  Now we can get into the nuts and bolts of the actual algorithm,
our first guess is that the OOF code is using the wrong K matrix
at the start of each step -- this plus the fact that the NR iterations
don't necessarily converge means that the deviation can accumulate
(although we don't know if it actually does.)

  Evidence:  Looking at the instrumented code, the initial
Cauchy stress that is being handled by the plastic constitutive
rule is a *lot* larger in the OOF code than it is in the prototype
code -- e.g. at t=400 in the usual output, the initial stress that
the algorithm is seeing is 1.665 GPa, but after convergence,
it goes to around 450 MPa.  At the same step, the prototype code
is seeing 448 MPa, and converges to 442 MPa.  

  The Cauchy stress evidence is from the Cauchy equivalent of 
the converged 2nd PK stress after step 16 in the algorithm outline
of the cheat-sheet (e.g. after "until S is converged.")

  Q: Can we check the actual K?  That's the thing to nail down.

   ------------

  April 2023:  It looks like the initial static solution 
does not actually solve the K matrix?  What's up with that?
(Did we turn that off?)

  Also, run it with a big time step -- maybe 30 or so.  If you
also increase the # of NR iterations, you can start to get 
something that looks like convergence.  
