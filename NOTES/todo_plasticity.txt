
  Feb. 21, 2020 --

  Closing in on plasticity, but starting to side-line a few 
important issues.  They're collected here.


  Done:  Time is now passed in to the stepper, the plasticity property
         deduces dt at run-time.

  Todo:

  - Stepper is malfunctioning, it's doing the linear pre-solution
      part correctly, but then when it starts the nonlinear solution,
      it starts from the prior time-step data, not the 
      linear solution.  This breaks the plasticity algorithm.

  - Are we doing the integrals correctly?  With the right
      Jacobian?

  - The NR solver requires the residual to be computed -- 
      double-check that the new equation class is actually doing this
      in the right way.
    In particular:  The property is populating a "static flux value"
      member of the fluxdata object, which goes into the "residual"
      data member of the LinearizedSystem class, but it's not the
      residual, it's the flux, which is combined with the applied
      forces when it's pulled out.
 
  - The NR solver has this tricky business where it selects an 
      optimal step size.  But extra evaluations of make_linear_system
      trigger physical changes by adding additional plastic strain.
      Is this OK?  (Temporarily disabled.)

  - Double-check the caching, see if we're doing too much work.
    - Sub-item: Shape function derivs could benefit from 
       caching answers, and knowing when the displacement field
       has changed.

  - In the equation construciton process, we're still not doing
      the geometrically-nonlinear piece, the equation is the standard
      OOF equation with a nonlinear constitutive rule.
 
  - The OOF constitutive rule is written in terms of all 9 elements
      of the strain and stress.  Once we're happy with the numbers,
      it should be re-written in terms of the strain six-vector,
      where possible.

  - There is an implicit assumption that there are only displacement
      DOFs in the subproblem.  This is likely to be true for real
      problems, but should maybe be more robust.

  - Possibly the property should be smarter about its statefullness,
      if it knew it was being evaluated "again" at a time-step, it
      could save some work and/or retrieve old data?
    This involves adding the time to the GptData object, and a check
      to notice new times.
    Allows the time-step to be nonuniform, also, which is handy.
    A possible mechanism for this is, if are being called for a
      time t and deformation F that you have seen before, just
      return the data you already have.

  - The OOF infrastructure is built for a general nonlinear solver,
      which might be either Newton or Picard -- they differ in what
      functions they call to retreive data, we should investigate
      if it makes sense to plasticity and Picard solvers.
      (TODO 1st: Review how Picard solvers work...)

  - We may have assumed that IncrementalStepper increments and the 
      requested outputs are commensurate, so we never have to take
      a partial step?  Check this.

  - The currently-coded incremental stepper is incapable of taking
      a linear step.  Incremental linear steps are trivial, you just
      statically evaluate at the new time.  This is a weird thing to 
      want, so we're deferring implementation of this.
 
  - What does it actually really mean for the time-stepper to 
      return stepOK?  Does it mean it reached the target, or just
      that it took a single step successfully?
 
