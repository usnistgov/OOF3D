
  Feb. 21, 2020 --

  Closing in on plasticity, but starting to side-line a few 
important issues.  They're collected here.


  Done:  
    Time is now passed in to the stepper, the plasticity property
      deduces dt at run-time.
 
    Stepper appears to be operating correctly, but differs from the
      prototype code due to the prototype's use of a different
      method (the "penalty method") to do the fixed BCs.  

    Integrals are done correctly with the right Jacobian.

    Outputs work for evaluations at gausspoints, which involved
      most of the infrastructure.  Needs to be generalized.

  Pending: 
  - The NR solver has this tricky business where it selects an 
      optimal step size.  But extra evaluations of make_linear_system
      trigger physical changes by adding additional plastic strain.
      Is this OK?  (Temporarily disabled.)

  - The NR solver also bombs out if it exceeds its allotted step
      count, but in plasticity, general practice is that a small
      number of steps is OK.  Currently, it's modified to continue
      after exceeding the step count, but what we really want is
      a better convergence criterion, probably.

  Todo:

  2nd:
  - The NR solver in OOF differs from the prototype code in that
      it's computing very high stresses for the initial time steps.
      It's not obvious why it should do this, but the initial stress
      looks very much like it's maybe some kind of purely elastic
      number?
    First guess is that the the starting K at the start of each
      time-step is somehow the initial K?  Probably the prior K 
      matrix is not being saved.

  - Outputs are basically working, but need to evaluate plastic 
      info at arbitrary points in space, not just GPs.
      
  - In the NR solver, it would be useful to provide it with an
      initial guess for the delta for the first iteration.
    SK says he does this with the deltas from the static step?

  - The NR solver requires the residual to be computed -- 
      double-check that the new equation class is actually doing this
      in the right way.
    In particular:  The property is populating a "static flux value"
      member of the fluxdata object, which goes into the "residual"
      data member of the LinearizedSystem class, but it's not the
      residual, it's the flux, which is combined with the applied
      forces when it's pulled out.
 
  1st:
  - In the equation construciton process, we're still not doing
      the geometrically-nonlinear piece, the equation is the standard
      OOF equation with a nonlinear constitutive rule.
    Fixing this involves re-working the property classes, 
      no more Flux or Eqn properties, just properites that 
      make contributions to one or the other or both.

  - Double-check the caching, see if we're doing too much work.
    - Sub-item: Shape function derivs could benefit from 
       caching answers, and knowing when the displacement field
       has changed.

  - There is an implicit assumption that there are only displacement
      DOFs in the subproblem.  This is likely to be true for real
      problems, but should maybe be more robust.

  - Possibly the property should be smarter about its statefullness,
      if it knew it was being evaluated "again" at a time-step, it
      could save some work and/or retrieve old data?
    This involves adding the time to the GptData object, and a check
      to notice new times.
    Allows the time-step to be nonuniform, also, which is handy.
    A possible mechanism for this is, if are being called for a
      time t and deformation F that you have seen before, just
      return the data you already have.

  - The OOF infrastructure is built for a general nonlinear solver,
      which might be either Newton or Picard -- they differ in what
      functions they call to retreive data, we should investigate
      if it makes sense to plasticity to use the Picard solvers.
      (TODO 1st: Review how Picard solvers work...)

  - We may have assumed that IncrementalStepper increments and the 
      requested outputs are commensurate, so we never have to take
      a partial step?  Check this.

  - The currently-coded incremental stepper is incapable of taking
      a linear step.  Incremental linear steps are trivial, you just
      statically evaluate at the new time.  This is a weird thing to 
      want, so we're deferring implementation of this.
 
  - What does it actually really mean for the time-stepper to 
      return stepOK?  Does it mean it reached the target, or just
      that it took a single step successfully?
 
