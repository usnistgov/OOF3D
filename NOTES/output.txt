
  The general structure of outputs:

  (Possibly specific to the OOF3D plasticity branch at this point....)

  There's a base Output class, in SRC/engine/IO/output.py, which 
has actual outputs as sub-classes.
  
  Output specializations have an "otype" (scalar, vector, tensor).

  They don't appear to be tied to a particular femesh.

  Outputs are in general chainable, i.e. you can create a new
output that has other outputs as inputs, for doing things like
arithmetic or statistics(?) on mesh-derived quantities.


  For some outputs, the knowledge of how to produce them from
field data is only known to properties -- e.g. energy is like this,
as is stress (of course).  Some coupling properties (e.g.
thermalexpansion, piezoelectricity) have a "Strain" output 
type.

  These "derived" output types are known at property 
registration time.

  I think there is an assumption that these can be evaluated at 
any point in space.

  The base property class has a C "output" method, which takes as
an argument the output object, which it can query to see what 
type it is (ugh), and populate it appropriately.

  See, e.g., the output method in elasticity.C for a simple
demo of how this works.

  Q: If you ask for an output and no property can do it, 
what happens?  Can you even pose this query?

  Q2: Are the flux values saved in the subproblems somewhere
and just retrieved at output-time, or are they recomputed?
For plasticity, recomputation might be bad, as it may re-run the
increment when it shouldn't. 

   --------
 
  Step 1: Figure out how to extract ElementData sub-units 
from a subproblem.

  Step 2: Figure out how to extract the stress, with special
attention to whether we are re-evaluating steps or not.
 
  Step 3: Figure out how to do an integral -- new sampler/domain?
    Reference vs. deformed configuration as the domain?

  ---------

  Convo w/Shahriyar June 17, 2021:
  - Wants to avoid every-time-step data.

  Near-term objective is to do a stress-strain curve, for which
we need the Cauchy stress (available in the GptPlasticData object
at the gausspoints), and the strain, we want FtF-I, as one useful
output, and also log(FtF), which is log(C), which is also a 
useful thing.  FtF is called the "(right? left?) Cauchy-Green 
deformation tensor."  FtF-I doesn't have a name(?), but it's the 
thing that's conjugate to the 2nd PK stress.
  
  Output call chain:  

  For PropertyOutputs, it goes through the PropertyOutputRegistration's
"opfunc", which is a base PropertyOutputRegistration object,
which calls begin_all_subproblems for each element, which 
calls begin_element, which might be bad, we do a lot of 
work in begin_element, but if the time-stamp hasn't changed,
then maybe it's OK.

  The femesh.spy's "begin_all_elements" function is apparently
called as part of the propertyoutput call sequence, but not as 
part of the solver process?  And it's broken because of changes
we made to begin_element?
  (August 2021)
  -> Fixed this.  The conjecture is true, this 'begin_all_elements'
call-chain is only for outputs.  The "begin_element" call was split
into "begin_element_matrix" and "begin_element_output", (along wiht
end_element, of course), and the "begin_all_elements" only
calls the output ones. 

 --------------------

  July 2021: Got the Smallmatrix3 and Symmmatrix3 output types
working without crashing.

  Next up:
  - Hack in something to make the begin_element call a no-op for
property outputs for properties we care about.
  - Figure out how to register a property output that will 
get stuff out of the Gausspoints.  In principle, this thing can
figure out how to evaluate at arbitrary points in space,
or maybe the callback does that?

  Q1: Where is it called from? 
    Line 110 of engine/IO/propertyoutput.C is the important one,
      inside PropertyOutput::evaluate.  There is already an 
      implciit element.
    This call is currently commented out.  NB this 
      calls *material* begin_element,
      not the elemental one.
    
  Material::begin_element (line 271, engine/material.C) calls 
    property->begin_element on all the props in the material.
 
  In the solver sequence, this is called from 
Element::make_linear_system, so this is the place to pass through
a "no, really, do the work" flag, if necessary.

  Thoughts about the architecture:

  The OO way would be to have a different function for each
of these call chains.  How to express the difference?

  - begin_element_matrix
  - begin_element_output

  -> Corresponding end_element?
  -> Do properties need this also?
  -> Any nontrivial examples?
  
  -------

  Actual call-chain:
 
  Starts when you hit the button (or from the scheduled
output, which we will care about later.)

  At the bottom of engine/IO/GUI/analyzePage.py, the callback for the
menu item, with "data=" the output object.  This is a 
DirectOutput instance in our case.

  The menuitem is a Direct_Output menu item, defined on 
line 466 of engine/IO/analyze.py. (Class is defined
above this.)

  Class hierarchy:
   DirectOutput -> DataOperation -> RegisteredClass
   The menu item is created on line 164 from the DataOperation
     registered class table.

  The next bit is the standard menu-item invocation, and shouldn't
    be hard, but the weird thing here is that I am seeing some
    output after IDing the class, and before the __call__ method
    of the DirectOutput?

  The "callWithDefaults" (line 173, common/IO/oofmenu.py)
   ... calls callWithArgdict, which calls hireWorker, 
   ... which builds a worker and starts it. 
   ... and the worker (work.py, line 132-ish) runs menuitem.callback
   ... which is _ops_callback
   
  *This* function calls precompute_all_subproblems, and then
    calls the registered output object's "call" method
    (as "operation()", which is menuitem.data(), which is the
     registered class object.)

  Takes you to Direct_Output.__call__, line 430 of engine/IO/analyze.py 
  This calls sampling.evaluate, in our case a PointSampleSet.

  This is the "evaluate" function at line 142 of analysissample.py.

  This function calls output.evaluate.

  Output evaluate is in the Python base class, Output, line 525
of engine/IO/output.py, and it calls "self.callback", which is
(via instrumentation) a method of the PropertyOutputRegistration
instance, specifically the "opfunc" method.
  
  This is the "opfunc" of the PORegBase, which is the base
of the class hierarchy based on return type.  This
*again* calls precompute_all_subproblems (???), and then
calls self.initializer.

  This goes into the POInitDeformation::operator(), which 
builds a zero smallmatrix3 and returns it (only nontrivial
method in engine/deformation.C).

  The initialization is because in principle you could have
related deformation types that add or subtract from the basic
one in their more-specific methods, I think?

  ---------
  
  For strain, we want true or logarithmic strain.  Need to get
the log of the strain tensor.  But we can start with the 
Green-Lagrange strain vs 2nd PK stress.

  ---------

  Green-Lagrange strain is 0.5*(F^TF-I) 

  Should be easy to add?  We don't need a new output type.

  - Header file, engine/glstrian.h
  - Actual code, engine/glstrain.C
  - Swig file, reflects h file, engine/glstrain.swg
  - spy file, register the thing, and define the type parameter.
