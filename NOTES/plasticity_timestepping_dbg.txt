
  June 2021:

  Debug version of this:  Second pass to add object traffic,
and monitor data flow.

  ------------------------------------------------------------------

  --------

  Additional (minor) points of confusion:  (Sept. 24)

  The uniform time-stepper with forward Euler builds the matrices
at the start of every time-step, so there's no matrix
construction step for the last time.  This caused brief confusion,
because forward Euler is wrong for this problem. 

  I think we want a new stepper, provisionally called "Incremental", 
which can take time-steps without generating output, and which
could possibly have better initial guesses, because it can 
actually do the thing where you use the prior K matrix for
the next time-step's initial solution.

  Need to get a better grip on the steppers before this
can happen.

  Meanwhile:

  Also, in the example solution, there are no free DOFs?  It's a 
1x1x1 mesh, so all the nodes are boundary nodes, but only x component
is constrained by boundary conditions.  What happened to y and z?
(Possibly the thing is just mis-reporting?)

  (Request from SK:  Input/output pairs from the plasticity property,
    i.e. incoming F, generated w)

  (Did this, for low delta-F, we are getting good answers.)

  Stepper base classes are in engine/timestepper.py, except for the 
static one, which is in staticstep.py.  F and B Euler are in 
euler.py. 


  Object structure at Solve Time:
  ------------------------------

  When the solve button is pressed, several things are true.

  The problem is well-posed, in the sense that fields and equations
are defined.  Boundary conditions are defined, as a (possibly trivial)
function of time.

  There is an "Output schedule", a set of times at which outputs
are requested.  This is not necessarily related to the step size.

  There is a Solver, which contains a Time-Stepper, which in turn 
contains a Stepper, which may define a step size.  The solver
has a nonlinear solving algorithm (e.g. Newton or Picard), and matrix
solvers for symmetric or unsymmetric matrices.

  The "nonlinear_solver" (which might be linear) attribute of the
subproblem is the thing that takes the linear system and computes
the DOFs at the next available time, using the stepper.
(See below.)  It's actually a property, implemented by a
_getNonlinearSolver method, which refers to a "private" 
attribute, _nonlinear_solver.  (Which also might be linear.)

  The NewtonSolver is in nonlinearsolver.py.
  The Forward Euler stepper is in euler.py.
  The Incremental stepper is in incremental.py.

  The NewtonSolver has a "core", which has a "solve" method which
does the actual work, which calls *out* to the passed-in 
"compute_jacobian" routine, along with the "data".  

  The subproblem has matrix methods, but apparently gets them
from the solver definition, where they are specified by the user.
The "set_solver" menu item is in the subproblem menu tree, so this
is not the wrong scope, but it's weirdly indirect.

  Following the control-flow will help, maybe?


  --------------------

  Trace notes:
  
  EPY -> evolve.py
  EPY-IS -> Initialize static fields in evolve.py
  EPY-ET -> Evolve_to in evolve.py

  IS-NL -> Incremental stepper, nonlinear step, incremental.py
  IS-DS -> Incremental stepper, _do_step routine, incremental.py

  SCPY-MM: subproblemcontext.py, matrix_method function.
  SCPY-IS: subproblemcontext.py, initialize static fields.
  SCPY-CS: subproblemcontext.py, compute static fields.
  SCPY-CSNL: subproblemcontext.py, compute nonlinear static fields.
  SCPY-MLS: subproblemcontext.py, make_linear_system.

  CSP: csubproblem.C.
  
  NLS-NLS: nonlinearsolver.py, NonlinearSolver class "step" method.
  NLS-N: nonlinearsolver.py, Newton class "solve" method. 
  
  NLSC-S: Nonlinear solver core, Newton "solve" method.
  
  TS-UD: timestepper.py, UniformDriver's nonlinearstep method.


  High-level questions are, what's up with the MeshDataCache
object, what's the data flow of the solution process?
 
  The full time-evolution call chain for the incremental stepper
with Newton-Raphson nonlinear solver, with filenames:

  File evolve.py, function evolve is called from the menu item.
  - Get the start time from the meshcontext. 
  - Call meshctxt.solver_precompute()
  - Call meshctxt.setStatus() -- comment says to sync geometry.
  - Try:
    - Initialize statistics
    - Check if it's a continuation, if not:
      - call initializeStaticFields (local)
        File evolve.py, function initializeStaticFields()
        - Loop over subproblems:
          - Call make_linear_system at the current time.
              -> We think this is harmless, no increments present, t=0.
          - Subproblem book-keeping -- startstep, cacheconstraints.
        - Subproblem consistency while-loop:
          - Loop over subproblems:
            - Call subproblem.initializeStaticFields
              File subproblemcontext.py, function initializeStaticFields
              - Check self.time_stepper's derivOrder.
              - If static fields make sense:
                - Get the unknowns from the linearized system
                - Call self.computeStaticFields
                   File subproblemcontext.py, function computeStaticFields
                   - Check derivOrder again.
                   - Call self.nonlinear_solver.computeStaticFields()
                     File nonlinearsolver.py, function NonlinearSolver.computeStaticFields():
                     - Call subprobctxt.computeStaticFieldsNL(..)
                       File subproblemcontext.py, function computeStaticFieldsNL():
                       - Call time_stepper.get_unknowns for data.
                       - Build nlfuncs object.
                       - Call self.nonlinear_solver.solve w/ self.matrix_method
                         File: nonlinearsolver.py, function Newton.solve()
                         - Call nonlinearsolvercore.Newton.solve()
                           File: nonlinearsolvercore.py
                           Function: Newton.solve
                           The precompute, compute_residual, 
                               compute_jacobian fns are passed in.
                           - set requireResidual, requireJacobian
                           - call precompute, get residual
                           - Compute the residual, find the norm.
                           - While norm is large and icount in-bounds:
                             - Zero-out the update data
                             - Compute the jacobian
                             - Negate the residual
                             - Call matrix_method.solve to get updates.
                             - Select increment size (disabled for us!)
                             - Add "update" to "values". 
                             - Recompute residual, get norm.
                             - Re-run precompute, passing values.
                         - Update stats.
                (Back in subproblemcontext.py:initializeStaticFields)
                - Call self.installValues 
            - Increment subproblem timestamp
            - Check consistency -- did the subproblems change?
        - Return dictionary of linearized systems.
            (from evolve.py:initializeStaticFields to evolve.py:evolve,
                around line 100)
      - (Return from initializeStaticFields)

      - Do the initial output.
    - Check if problem is static, exit if it is.

  ---- End of static initialization -----

  - Do some book-keeping about the time-step delta.
  - Loop over requested output times: (Or more often, if delta small?)
    - Loop over subproblem steppers, find minimum delta.
    - Call evolve_to with the subproblems and a target time (local)
      File evolve.py, function evolve_to() (line 281 or so)
      - Try:
        - While not finished or commanded to stop:
          - End-time book-keeping.
          - Loop over subproblems:
               --> Problem call? Re-using K or not? <--
            - Run make_linear_system on a subproblem.
            - startstep, cacheconstraints.
          - Subproblem consistency loop:
            - Subproblem loop:
              - Clone the linearized system, grab the unknowns
              - Call subproblem.nonlinear_solver.step.
                  HERE
              - If result is OK, update linearized system.
            - Check consistency.
      - Return from evolve_to() with consistent subproblems.
    - Book-keeping checks for possible errors
    - Possible conditional outputs
  - Run post-compute operations, update stats, exit.


  -----------

  Follow-up, June 2022:

  Weird things are happening with the stepper, it's not doing the
right matrix at the start of the time step.  Suspicion centered
on the step taken at line 347 or so of hte evolve.py file -- inside
evolve.py, there's a static evalution that might be wrong.

  Removing the static evaluation is differently wrong, though,
it causes the plastic constitutive rule to blow up farther down
the line.  This too is odd, it blows up after 75 time steps, 
well into the plastic regime, at a point where it's not obvious
what would be different.

  Doing this step only once for each call to evolve_to behaves
the same as not doing the call at all.

  Note:
  ----

  The preliminary model of the issue does not make a lot of sense in
light of the actual code -- there is no process we have written that
will generate the elastic K matrix, so the idea that late iterations,
by not reusing the elastoplastic K, will have artificially high
stresses, is impossible.  They might have artificially high stresses
for some *other* reason, or there might be some other Fp-dependent
thing that's happening or failing to happen, but the "wrong K"
argument is not supported by the code paths.

  Next step: Better instrumentation.

  Add the time-step number, time, iteration number, element index,
    and maybe slip system index, to all the print statements.

  Maybe Emacs json mode with hs minor mode? (js-mode and hs-mode, for hide-show mode)
  Allows to expand blocks, possibly at many levels?

  Outline-mode might be oK too, but it lacks the ability to e.g. have a higher
level of the hierarchy continue after an enclosed lower-level entity has 
"closed" and is no longer operative, it's strictly hierarchical. 

