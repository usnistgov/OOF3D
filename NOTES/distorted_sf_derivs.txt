
  The call chain for evaluating shape function derivatives
in a distorted ("current") configuration:

  You begin with an ElementFuncNodeIterator.

  This has a method, "displacedsfderiv(element, component, gpt, mesh)"
(ElementFuncNodeIterator::displacedsfderiv in elementnodeiterator.C)

  (You have to pass the element through because you need field
  data farther down the chain.)

  That method calls the element's master-element's shape-function
"displacedderiv(element,iterator-index, component, masterpos, mesh)"
(ShapeFunction::displacedderiv() in shapefunction.C)

  This starts a dispatch process -- calls
masterpos.displacedderiv(element, sf, mesh, sf_index, component)

  Depending on the sub-type of MasterPosition, it dispatches 
differently:

  GaussPoint::displacedderiv just calls sf.displacedderiv(el,n,i,sf,mesh)

  MastertCoord::displacedderiv() does the same thing, but there's
presumably no caching?

  These land in different places in shapefunction.C:

  ShapeFunction::displacedderiv(el,n,i,gpt, mesh) (Line 157)

  ShapeFunction::displacedderiv(el,n,i,mpos,mehs) (Line 174)

  Because of the argument-type overloading, this actually isn't an
infinite loop.

  These both call through to element->deformation_jacobian, which 
they contract with the "masterderiv".

  deformation_jacobian is in element.C.
