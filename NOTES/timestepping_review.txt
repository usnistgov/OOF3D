
  Review of how the time-stepping actually works -- distinct from 
the "timestepping.txt" document in this directory, which is about
the initial design, which may or may not have happened.

  Classes:

  StepDriver, defined in engine/timestepper.py, base class
    for ways that single time steps can be combined into
    a full time evolution.  This is a value of the
    "AdvancedStepDriverParameter".
  Subclasses:
   - AdaptiveDriver
   - UniformDriver
   - StaticDriver (defined in engine/staticstep.py)

  Drivers have "linearstep" and "nonlinearstep" methods, which 
    call through to the stepper methods.  


  BasicStepDriver - base of the "basic" drivers, with few options, easy to use.
  This is a value of the "BasicStepDriverParameter".
  Subclasses:
  - BasicAdaptiveDriver
  - BasicUniformDriver
  - BasicStaticDriver
  The "Basic" drivers do not contain steppers directly, what they 
    do is have "resolve" methods which interrogate the problem
    type and return the appropriately-parametrized "advanced" 
    (no-prefix) step driver object.
  These things aren't real, they're just user interface wrapper classes.



  TimeStepper -- base class for various ways of taking a single
    time step.
  Subclasses: (almost trivial)
   - LinearStepper
   - NonLinearStepper
  
  LinearStepper and NonLinearStepper base classes are very small,
    nonlinear one has a "precompute" method, but basically these
    are place-holders for a "linearstep" (for LinearStepper) 
    and "nonlinearstep" (for NonlinearStepper) methods.
  These methods return a "StepResult" object.

  Nonlinear solvers call "precomputeNL" on the nonlinear
    stepper.
 
  There's also an "NLData" object associated with individual
steppers that that contains:
   -> subproblem
   -> linearized system object "linsys"
   -> time
 
  The IncrementalStepper defines "IncrementalNLData" for this role.


  NonStaticStepper (not a subclass of TimeStepper):
  Subclasses:
   - FirstOrderStepper
   - SecondOrderStepper

  QCTimeStepper -- base class for "quality-controlled" (i.e. error-bounded)
    steps. 
  Subclasses:
   - RKF45 (incomplete)
   - TwoStep -> in engine/twostep.py, takes one big step and two 
       half-size steps and compares the answer, for adaptive stepping.
 
  ------------------------------

  Solvers:

  Start with engine/nonlinearsolver.py. 

  NonlinearSolverBase , registered class.
  Subclasses:
  - NoNolinearsolver (linear solver)
  - NonlineraSolver
    - Newton 
    - Picard 

  The nontrivial classes (NoNonlinearSolver, Newton, Picard)
    are also subclasses of the corresponding nonlinearsolvercore
    objects.
  
  The nontrivial classes have "step" and "computeStaticFields"
    methods.  The "step" method calls out to the stepper, 
    passing "self" as "nonlinearMethod".
  Newton and Picard also have a "solve" method which calls
    the core's "solve" method.

  The SolverCore objects implement the actual algorithm, e.g.
    Newton or Picard, in their "solve" methods, which is called
    by the non-core methods, mentioned above.

  Newton method interacts with the system state through the 
    precompute, compute_residual, and compute_jacobian.
  The methods for doing these are passed through from the 
    call to the non-core solver, where they are just "*args, **kwargs".

  ------------

  Control flow note:

  The call to the solver's step routine is indirect:
  From evolve, the call is to the solver's step routine, which
calls the stepper driver's nonlinearstep routine, which calls
the stepper's nonlinearstep routine.

  Need to know more about actual steppers.

  They are in separate files:  twostep.py, rk.py, ss22.py, 
staticstep.py, and of course incremental.py.

  The incremental stepper calls "nlmethod.solve" as part of its
"nonlinearstep" call chain.  The precompute, compute_residual, and
compute_jacobian functions are part of an "ilfuncs" object, which 
is of type IncrementalNLFuncs, and there's a "data" thing that's
getting passed around also, which is an "IncrementalNLData" 
object with the linearized system, time and subproblem in it.

  This is the main loop.  

  -----------------------

  Subproblems:

  Owns the top-level make_linear_system.

  Has a solver_precompute method, check this.
   -> Calls through to material precompute.
  Possibly-complex state management, has a "changed" routine which
updates book-keeping info when things have changed, like new
fields added etc.
  Has a "matrix_method" function which solves a linear system,
picking a method depending on symmetry of the passed-in matrix.
Actual call is to MatrixSolverWrapper.

  Interesting: Subproblem's make_linear_system has a lot of 
logic about what to recompute -- possibly it's making the mistake here
and re-building K when it shouldn't?

  Also has "computeStaticFields", which switches out to 
either linear or nonlinear helper function.

  ------------

  First crack at the control flow -- the conditional in the 
subproblem about rebuilding the matrix is working at least some
of the time, we get "false" for this 2x out of 4 in a simple test.

  But we don't understand the test -- it should be either 3 or 5 calls,
we think.

  Next step: Understand the context better.

  Expected behavior: True from evolve, then False at the start of
a timestep, then True within the NR loop, then False at the start
of the next time-step, and True in the NR loop, and so on.

  -------------

  July 29:  What we are seeing is that the subproblem is always
rebuilding the matrices because it believes there are new field
values, and the problem requires the residual. 

  Q: What does "newFieldValues" actually depend on?
    Line 829 of subproblemcontext.py:
   newFieldValues is set when self.fieldsInstalled or mesh.fieldsInitialized
     is greater (in time-stamp sense) than when the linear system was
     last computed.   (Or, "always" can be set, but it's not set in 
     our tests.)
   (subproblem=self).fieldsInstalled is set by set_mesh_dofs.
   Called from subproblem.installValues and subproblem.moveOn, the 
   latter being done at the end of the time step. 

   I suspect the moveOn call, but need to review the logic of 
the incremental stepper to be sure.

  ----------------

  How does an iteration actually go, for the plasticity case?


  -------------------

  Follow-up about newFieldValues:

  This is set in subproblemcontext.py, line 833 or so, in make_linear_system,
where it's true if:
  - self.fieldsInstalled or mesh.fieldsInitialized is greater 
       than linsysComputed
  (or "always", but "always" is turned off for our case.)

  Examining the instrumented code shows that it's the 
"self.fieldsInstalled" that's getting incremented and motivating
the bad answer for the matrix-rebuilding.
 
  This is incremented to a new current time-stamp value (not just
by one, because of how timestamps work!) in set_mesh_dofs. Who
is calling set_mesh_dofs?  Mostly called from within subproblemcontext.py,
according to a search of the source.

  Called by "moveOn" (at the end of every step?), and by 
installValues (when?).

  Looks like there are possibly-redundant calls to this, that we
used to think were harmless because overwriting the same values 
is OK, but in fact, it changes state data, which we now are 
sensitive to.

