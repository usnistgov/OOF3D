
  Plasticity has special requirements for the time-stepping.

  For each time-step, the first thing to do is build the stiffness
matrix without the elasto-plastic tangent piece, just assuming
(large-strain) elasticity.  Then, the loop you go into starts with
solving this system, evaluating the stress, and building a new
master stiffness matrix *with* the elasto-plastic part.

  A possible challenge for OOF is that, at the start of the 
solution process, you do not have a stiffness matrix, and there's
no current scheme to convey to the properties that this is 
the first pass for this time-step.  

  So, we either need a special time-stepper that can pre-build
the stiffness matrix, or speical parameters for an existing 
stepper that tells it to do what we want.

  For plasticity, we will be taking uniform steps, which in terms
of the OOF solution sequence, means we are living in the world
of "Uniform" step-drivers.  

  In the "all-up" test-case, we've selected:

  -> Uniform stepping, with delta-t of 0.001 (bad choice for quasi-static?)
  -> Forward Euler stepping (bad choice?)
  -> Newton nonlinear solver.
  -> CG + ILU symmetric solver, BiCG + ILU unsymmetric solver

  IMPORTANT:

  Confusion about how exactly the prototype algorithm works:

  Does it or does it not accumulate Fp during the NR steps?

  If it does, then the initial K matrix built with the moved
boundary conditions can create permanent spurious yielding near
the moving boundary.  The solution to this is to use (build or find)
an initial elastic K matrix, equilibrate with that at the start 
of the global NR time-step, and then begin the plastic iterations
from the elastic-equilbirated starting state.

  If it does not, then it's safe to do the "naive" approach,
just build the K you want with the squashed elements, which 
might have condition or convergence problems, and NR-iterate
towards a solution, which will have some amount of Fp, which
will be the same, but maybe slower, than if you didn't do this.

  Looking at the code, it suggests that we're doing the second
thing -- the relevant datum is the fp_tau entry in the plastic
data container for the gausspoints, which gets updated (*not*
accumulated!) inside the "begin_element" routine of the 
plasticity property.

  Q: Is there a phase error?  The most recent fp_tau persists in 
the gauss-point object, but it's from the last matrix construction,
not the last solution.  How bad is this?  Feels small.

  --------

  Additional (minor) points of confusion:  (Sept. 24)

  The uniform time-stepper with forward Euler builds the matrices
at the start of every time-step, so there's no matrix
construction step for the last time.  This caused brief confusion,
because forward Euler is wrong for this problem. 

  I think we want a new stepper, provisionally called "Incremental", 
which can take time-steps without generating output, and which
could possibly have better initial guesses, because it can 
actually do the thing where you use the prior K matrix for
the next time-step's initial solution.

  Need to get a better grip on the steppers before this
can happen.

  Meanwhile:

  Also, in the example solution, there are no free DOFs?  It's a 
1x1x1 mesh, so all the nodes are boundary nodes, but only x component
is constrained by boundary conditions.  What happened to y and z?
(Possibly the thing is just mis-reporting?)

  (Request from SK:  Input/output pairs from the plasticity property,
    i.e. incoming F, generated w)

  (Did this, for low delta-F, we are getting good answers.)

  Stepper base classes are in engine/timestepper.py, except for the 
static one, which is in staticstep.py.  F and B Euler are in 
euler.py. 


  Object structure at Solve Time:
  ------------------------------

  When the solve button is pressed, several things are true.

  The problem is well-posed, in the sense that fields and equations
are defined.  Boundary conditions are defined, as a (possibly trivial)
function of time.

  There is an "Output schedule", a set of times at which outputs
are requested.  This is not necessarily related to the step size.

  There is a Solver, which contains a Time-Stepper, which in turn 
containts a Stepper, which may define a step size.  The solver
has a nonlinear solving algorithm (e.g. Newton or Picard), and matrix
solvers for symmetric or unsymmetric matrices.

  The "nonlinear solver" (which might be linear) attribute of the
subproblem is the thing that takes the linear system and computes
the DOFs at the next available time, using the stepper.
(See below.)

  The NewtonSolver is in nonlinearsolver.py.
  The Forward Euler stepper is in euler.py.

  The NewtonSolver has a "core", which has a "solve" method which
does the actual work, which calls *out* to the passed-in 
"compute_jacobian" routine, along with the "data".  

  Following the control-flow will help, maybe?


  General Time-stepping Design:
  -----------------------------

  Within each sub-problem, in order to reach a designated time t,
the steppers decide how big of a time-step they can do (uniform
steppers just use their arguments, adaptive steppers attempt
large steps and assess error somehow), then take a step.  Each
stepper has a "_do_step" internal routine, which has access to
the linearized system, the static part at least of which has
been built, and knows its method.  If it needs more data,
e.g. the MCKa matrix at new time, it has to make calls to 
get that -- these are dispatched through the solver, which 
knows about the nonlinear solver, for instance.

  There's metadata that contains information about what's 
available, whether the Jacobian or the residual is needed,
and so forth.

  For the current plasticity set-up specifically, I think this is
being done wrong. the Jacobian is not being populated -- it's 
distinct from the K matrix in some way that I forget.


  Control flow:
  -------------

  Hitting the solve button takes you to the "Evolve" routine,
in SRC/engine/evolve.py.

  Evolve does a bunch of work at the initial time, including initializing
the static fields, which involves building the linear system at 
the initial time inside the "initializeStaticFields" routine in evolve.py.
According to the comments there, it is dispatched through the 
nonlinear solver, so nonlinearities are taken care of here.

  Then, Evolve loops over the times in the output schedule at which
the user has requested info, and for each time, calls "evolve_to" to 
bring the (possibly multiple) sub-problems up to that time.
  Note (again) that these times are unrelated to the stepper 
time-step.  The enclosed steppers will take as many steps as they
need to to hit the target time, with whatever algorithm they embody.
 
  The actual evolution happens in the "stepresult = " call,
to subproblem.nonlinear_solver.step(...)

  Evolve_to asks the steppers for their time-step, figures out the
new time at which it's evaluating the system, builds the linear 
system, and hands it off unconditionally to the nonlinear solver.
(In the trivial case, the nonlinear solver can be linear.)

  (The new time is passed through to the make_linear_system call --
this is where it should go to the properties, probably.)

  What happens next depends on the stepper.

  To solve the system, the stepper calls back out to 
subproblem.matrix_method, but this is apparently not e.g. the Newton 
solver?  (Examining Forward Euler makes this confusing...)


  Strategy:
  --------

  The thing to do is to create a new, "Incremental" stepper,
that builds the the static matrices, and uses the NR solver to 
do the under-the-hood linear algebra.   This will differ from 
the other steppers, in that it's not properly stateful,
when you do the solves, there will be stuff happening in the
gausspoints that's not part of the DOFs.  This will affect the
plasticity property's ability to inter-operate with other
properties, e.g. if we later want to dissipate heat from 
plastic work or something.

  Verified that, with the NL solver, the new equation is indeed
building the Jacobian matrix.  Messages are still strange, don't
get why it's reporting 0x0.

  Minor(?) confusion -- the "initialize static fields" flow does not
go through the MatrixSolverWrapper.
  
  ---------
  
  The thing we want is a replacement for the stepper, where
the current script is just using forward Euler.  We want an essentially
static thing, but where the next state depends on data from the 
previous state, because the properties we have are giving us deltas
which depend on the pre-existing values in the system.

  Q: Are there other, non-plasticity properties like this, in
principle?  Fluid flow might be like this.

  Copied over the ForwardEuler stepper, and made an Incremental
stepper, it shows up in the menus and gets called, so that's good.

  Oddity:  In testing, the residual norm is always zero, so the
matrix call-back is never triggered.  This might be because of bad
metadata in the stepper?  But it's tagged as nonlinear.  Possibly
the old explicit Euler code is actually handing it the C matrix?  

  Probably yes.  Writing a new stepper is totally the right move.
 
  The Question:

  The stepper needs to start from the old fields, so it needs
to do a thing where the first pass on the NR solver is to solve
the *old* matrix with the *new* boundary conditions without doing
any plasticity (which is done during matrix construction, so using
the old matrix is automatic in this case).
  NB this is a linear step, just one pass. 
  *Then* start the NR iterations, including matrix construction, 
with this solution as the initial guess.

  So it matters very deeply how the time-dependent boundary values
are handled.  These live in the Linearized System, maybe?

  --------------------

  Q's: How exactly do the solvers work, and what do they work on?
  Does our subproblem have a linear solver?  If so, what is it? 

  Trace notes:
  
  EPY -> evolve.py
  EPY-IS -> Initialize static fields in evolve.py
  EPY-ET -> Evolve_to in evolve.py

  IS-NL -> Incremental stepper, nonlinear step, incremental.py
  IS-DS -> Incremental stepper, _do_step routine, incremental.py

  SCPY-MM: subproblemcontext.py, matrix_method function.
  SCPY-IS: subproblemcontext.py, initialize static fields.
  SCPY-CS: subproblemcontext.py, compute static fields.
  SCPY-CSNL: subproblemcontext.py, compute nonlinear static fields.
  SCPY-MLS: subproblemcontext.py, make_linear_system.

  CSP: csubproblem.C.
  
  NLS-NLS: nonlinearsolver.py, NonlinearSolver class "step" method.
  NLS-N: nonlinearsolver.py, Newton class "solve" method. 
  
  NLSC-S: Nonlinear solver core, Newton "solve" method.
  
  TS-UD: timestepper.py, UniformDriver's nonlinearstep method.

 
  The full time-evolution call chain for the incremental stepper
with Newton-Raphson nonlinear solver, with filenames:

  File evolve.py, function evolve is called from the menu item.
  - Do some subproblem book-keeping.
  - Call meshctxt.solver_precompute()
  - Call meshctxt.setStatus() -- comment says to sync geometry.
  - Try:
    - Initialize statistics
    - Check if it's a continuation, if not:
      - call initializeStaticFields (local)
        File evolve.py, function initializeStaticFields()
        - Loop over subproblems:
          - Call make_linear_system at the current time.
          - Subproblem book-keeping -- startstep, cacheconstraints.
        - Subproblem consistency while-loop:
          - Loop over subproblems:
            - Call subproblem.initializeStaticFields
              File subproblemcontext.py, funciton initializeStaticFields
              - Check self.time_stepper's derivOrder.
              - If static fields make sense:
                - Get the unknowns from the linearized system
                - Call self.computeStaticFields
                   File subproblemcontext.py, function computeStaticFields
                   - Check derivOrder again.
                   - Call self.nonlinear_solver.computeStaticFields()
                     File nonlinearsolver.py, function NonlinearSolver.computeStaticFields():
                     - Call subprobctxt.computeStaticFieldsNL(..)
                       File subproblemcontext.py, function computeStaticFieldsNL():
                       - Call time_stepper.get_unknowns for data.
                       - Build nlfuncs object.
                       - Call self.nonlinear_solver.solve w/ self.matrix_method
                         File: nonlinearsolver.py, function Newton.solve()
                         - Call nonlinearsolvercore.Newton.solve()
                           File: nonlinearsolvercore.py
                           Function: Newton.solve
                           The precompute, compute_residual, 
                               compute_jacobian fns are passed in.
                           - set requireResidual, requireJacobian
                           - call precompute, get residual
                           - Compute the residual, find the norm.
                           - While norm is large and icount in-bounds:
                             - Zero-out the update data
                             - Compute the jacobian
                             - Negate the residual
                             - Call matrix_method.solve to get updates.
                             - Select increment size (disabled for us!)
                             - Add "update" to "values". 
                             - Reocmpute residual, get norm.
                             - Re-run precompute, passing values.
                         - Update stats.
                - Call self.installValues 
                    HERE
            - Increment subproblem timestamp
            - Check consistency -- did the subproblems change?
        - Return dictionary of linearized systems.
      - (Return from initializeStaticFields)
      - Do the initial output.
    - Check if problem is static, exits if it is.
  - Do some book-keeping about the time-step delta.
  - Loop over requested output times: (Or more often, if delta small?)
    - Loop subproblem steppers, find minimum delta.
    - Call evolve_to with the subproblems and a target time (local)
      File evolve.py, function evolve_to()
      - Try:
        - While not finished or commanded to stop:
          - End-time book-keeping.
          - Loop over subproblems:
            - Run make_linear_system on a subproblem.
            - startstep, cacheconstraints.
          - Subproblem consistency loop:
            - Subproblem loop:
              - Clone the linearized system, grab the unknowns
              - Call subproblem.nonlinear_solver.step.
                  HERE
              - If result is OK, update linearized system.
            - Check consistency.
      - Return from evolve_to() with consistent subproblems.
    - Book-keeping checks for possible errors
    - Possible conditional outputs
  - Run post-compute operations, update stats, exit.
