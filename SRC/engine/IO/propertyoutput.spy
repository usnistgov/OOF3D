# -*- python -*-
# $RCSfile: propertyoutput.spy,v $
# $Revision: 1.13.4.3 $
# $Author: fyc $
# $Date: 2014/07/28 22:17:51 $

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov.

from ooflib.SWIG.engine import outputval
from ooflib.SWIG.engine import symmmatrix3
from ooflib.SWIG.engine import smallmatrix3
from ooflib.common import debug
from ooflib.common import utils
from ooflib.engine.IO import output
from ooflib.engine.IO import outputClones
import types, sys

# The PropertyOutputRegistration subclasses create an Output object
# for each registered PropertyOutput.  This bridges the gap between
# the C++ PropertyOutputs and the more general Python Outputs.

class PORegBase(PropertyOutputRegistration):
    ## Callback for all PropertyOutputs.  Outputs that need to return
    ## something other than a list of OutputVal instances should
    ## override the convert method.
    def opfunc(self, time, mesh, elements, coords, **params):
        print >> sys.stderr, "Inside PORegBase.opfunc."
        po = self.instantiate(params)
        mesh.precompute_all_subproblems()
        initializer = self.initializer()
        print >> sys.stderr, "Initializer is ", initializer
        results = []
        for element, ecoords, in zip(elements, coords):
            mat = element.material()
            mesh.begin_all_subproblems(time, element)
            results.extend(po.evaluate(time, mesh,
                                       element, initializer, ecoords))
            mesh.end_all_subproblems(time, element)
        return self.convert(results)
    def convert(self, results):
        return results
    
##### Scalar outputs

class ScalarPropertyOutputRegistration(PORegBase):
    def __init__(self, name, initializer=None, parameters=[], ordering=0,
                 srepr=None, tip=None, discussion=None):
        PropertyOutputRegistration.__init__(
            self, name, initializer or ScalarPropertyOutputInit())
        op = output.Output(name=name,
                           callback=self.opfunc,
                           otype=outputval.ScalarOutputValPtr,
                           instancefn=outputClones.scalar_instancefn,
                           column_names=outputClones.single_column_name,
                           params=parameters,
                           srepr=srepr, tip=tip, discussion=discussion)
        output.defineOutput(name, op, ordering=ordering)

#     def convert(self, results): # convert from ScalarOutputVal to Float
#         return [r.value() for r in results]
    
##### SymmMatrix3 outputs.

# def _symmmatrix3_instancefn(self):
#     return symmmatrix.SymmMatrix3(0.,0.,0.,0.,0.,0.)

# def _symmmatrix3_column_names(self):
#     sr = self.shortrepr()
#     names = []
#     it = self.outputInstance().getIterator()
#     while not it.end():
#         names.append("%s[%s]" % (sr, it.shortstring()))
#         it.next()
#     return names

# class SymmMatrix3PropertyOutputRegistration(PORegBase):
#     def __init__(self, name, initializer=None, parameters=[], ordering=0,
#                  srepr=None, tip=None, discussion=None):
#         PropertyOutputRegistration.__init__(
#             self, name, initializer or SymmMatrix3PropertyOutputInit())
#         op = output.Output(name=name,
#                            callback=self.opfunc,
#                            otype=outputval.OutputValPtr,
#                            instancefn=_symmmatrix3_instancefn,
#                            srepr=srepr,
#                            column_names=_symmmatrix3_column_names,
#                            params=parameters,
#                            tip=tip, discussion=discussion)
#         output.defineOutput(name+":Value", op, ordering=ordering)

#         def comprepr(s):
#             comp = s.resolveAlias("component").value
#             # We have to pass s to op.shortrepr so that the shortrepr
#             # will be computed for the actual Output, not the Output
#             # defined above.  The actual output will be a clone of the
#             # one defined there.
#             return "%s[%s]" % (op.shortrepr(s), comp)

#         compout = outputClones.ComponentOutput.clone(
#             name=name+" Component",
#             tip='Compute components of %s' % name,
#             srepr=comprepr,
#             discussion=
#             """
#             <para>Compute the specified component of %s on a &mesh;.</para>
#             """
#             % name)
#         compout.connect('field', op)
#         for param in parameters:
#             compout.aliasParam('field:' + param.name, param.name)
#         output.defineOutput(name+":Component", compout, ordering=ordering)

#         def invariantrepr(s):
#             invariant = s.resolveAlias("invariant").value.shortrepr()
#             # See comment above about op.shortrepr(s)
#             return "%s(%s)" % (invariant, op.shortrepr(s))
        
#         invout = outputClones.InvariantOutput.clone(
#             name=name+" Invariant",
#             srepr=invariantrepr,
#             tip='Compute invariants of %s' % name,
#             discussion="""
#             <para>Compute the specified invariant of %s on a &mesh;.</para>
#             """
#             % name)
#         invout.connect('field', op)
#         for param in parameters:
#             invout.aliasParam('field:' + param.name, param.name)
#         output.defineOutput(name+":Invariant", invout, ordering=ordering)


####################

class MatrixPropertyOutputRegistration(PORegBase):
    def __init__(self, name, instancefn, colnamefn,
                 initializer=None, parameters=[], ordering=0,
                 srepr=None, tip=None, discussion=None):
        PropertyOutputRegistration.__init__(
            self, name, initializer)
        op = output.Output(name=name,
                           callback=self.opfunc,
                           otype=outputval.OutputValPtr,
                           instancefn=instancefn,
                           srepr=srepr,
                           column_names=colnamefn,
                           params=parameters,
                           tip=tip, discussion=discussion)
        output.defineOutput(name+":Value", op, ordering=ordering)

        def comprepr(s):
            comp = s.resolveAlias("component").value
            # We have to pass s to op.shortrepr so that the shortrepr
            # will be computed for the actual Output, not the Output
            # defined above.  The actual output will be a clone of the
            # one defined there.
            return "%s[%s]" % (op.shortrepr(s), comp)

        compout = outputClones.ComponentOutput.clone(
            name=name+" Component",
            tip='Compute components of %s' % name,
            srepr=comprepr,
            discussion=
            """
            <para>Compute the specified component of %s on a &mesh;.</para>
            """
            % name)
        compout.connect('field', op)
        for param in parameters:
            compout.aliasParam('field:' + param.name, param.name)
        output.defineOutput(name+":Component", compout, ordering=ordering)

        def invariantrepr(s):
            invariant = s.resolveAlias("invariant").value.shortrepr()
            # See comment above about op.shortrepr(s)
            return "%s(%s)" % (invariant, op.shortrepr(s))
        
        invout = outputClones.InvariantOutput.clone(
            name=name+" Invariant",
            srepr=invariantrepr,
            tip='Compute invariants of %s' % name,
            discussion="""
            <para>Compute the specified invariant of %s on a &mesh;.</para>
            """
            % name)
        invout.connect('field', op)
        for param in parameters:
            invout.aliasParam('field:' + param.name, param.name)
        output.defineOutput(name+":Invariant", invout, ordering=ordering)




#####################


def _symmmatrix3_instancefn(self):
    return symmmatrix3.SymmMatrix3(0.,0.,0.,0.,0.,0.)

def _symmmatrix3_column_names(self):
    sr = self.shortrepr()
    names = []
    it = self.outputInstance().getIterator()
    while not it.end():
        names.append("%s[%s]" % (sr, it.shortstring()))
        it.next()
    return names

class SymmMatrix3PropertyOutputRegistration(MatrixPropertyOutputRegistration):
    def __init__(self,name,initializer,parameters,ordering,srepr,
                 tip,discussion):
        MatrixPropertyOutputRegistration.__init__(
            self,name,_symmmatrix3_instancefn,_symmmatrix3_column_names,
            initializer = initializer or SymmMatrix3PropertyOutputInit(),
            parameters=parameters,ordering=ordering,srepr=srepr,
            tip=tip,discussion=discussion)

#####################

def _smallmatrix3_instancefn(self):
    return smallmatrix3.SmallMatrix3()

def _smallmatrix3_column_names(self):
    sr = self.shortrepr()
    names = []
    it = self.outputInstance().getIterator()
    print >> sys.stderr, "OI is ", self.outputInstance()
    print >> sys.stderr, "IT iterator is", it
    while not it.end():
        names.append("%s[%s]" % (sr, it.shortstring()))
        it.next()
    return names

class SmallMatrix3PropertyOutputRegistration(MatrixPropertyOutputRegistration):
    def __init__(self,name,initializer,parameters,ordering,srepr,
                 tip,discussion):
        MatrixPropertyOutputRegistration.__init__(
            self,name,_smallmatrix3_instancefn,_smallmatrix3_column_names,
            initializer = initializer or SmallMatrix3PropertyOutputInit(),
            parameters=parameters,ordering=ordering,srepr=srepr,
            tip=tip,discussion=discussion)

#####################

# ThreeVector outputs
## TODO 3.1: There should be an "Invariant" output since 3-vectors have
## a magnitude.  srepr's and column_name's need to be
## adjusted/provided.  None of this is implemented yet because there
## are no ThreeVectorPropertyOutputs to test it on.

class ThreeVectorPropertyOutputRegistration(PORegBase):
    def __init__(self, name, initializer=None, parameters=[], ordering=0,
                 srepr=None, tip=None, discussion=None):
        PropertyOutputRegistration.__init__(
            self, name, initializer or ThreeVectorPropertyOutputInit())
        op = output.Output(name=name,
                           callback=self.opfunc,
                           otype=outputval.OutputValPtr,
                           instancefn=outputClones.vector_instancefn,
                           params=parameters,
                           srepr=srepr, tip=tip,
                           discussion=discussion)
        output.defineOutput(name, op, ordering=ordering)

        compout = outputClones.ComponentOutput.clone(
            name=name+" Component",
            tip='Compute components of %s' % name,
            discussion=
            """
            <para>Compute the specified component of <link
            linkend='Output-%s'>%s</link> on a &mesh;.</para>
            """
            % (name, name))
        compout.connect('field', op)
        for param in parameters:
            compout.aliasParam('field:'+param.name, param.name)
        output.defineOutput(name+":Component", compout, ordering=ordering)


